package jianzhioffer;

public class add {
//    或保留，与进位, 与为空时就返回
//    ^得到的是一个无进位的加法 这个结果可能要比a和b本身还小 比如18+3本来是21 但是异或后得到的是17 为什么呢？18：10010 3:00011 异或后：10001=17可以看到本来第二个1那个地方该进位的，异或后不仅没有进位，反而变成了0 这就相当于少加了00100这个数，那如何能得到这个数呢？使用&因为只有两个位都是1了才会进位，刚好对应两个1异或后消失的那个进位，但是&后需要左移一下才能模拟那个数。好，现在解决了如何用二进制表示加法 但是我们二进制得到的那两个数依然要加起来，怎么办呢？递归！递归到进位等于0了，那么异或得到的就是相加的正确结果。
    public static int add(int a, int b) {
        if (b==0)
            return a;
        int c = (a&b)<<1; // 进位赋值给c，准备下一次递归使用
        int d = a^b; // 非进位和赋值给d ，准备下一次递归使用
        return add(d,c);
    }

    public static void main(String[] args) {
        int a=1,b=1;
        System.out.println(add(a,b));
    }
}
